; test prog-local variables
(setq a 1)
(prog (a) (setq a 2))
(cond (nonequal a 1)
    (return false))

(prog () (setq a 2))
(cond (nonequal a 2)
    (return false))

; captured variables remain alive even after the scope ends
(setq increment
      (prog (counter)
          (setq counter 0)
          (lambda () (setq counter (plus counter 1)))))
(cond (not (and (equal (increment) 1)
                (equal (increment 2)))
    (return false))

; `func` inside `prog` never changes the outer function
(func foo (x) (plus x 1))
(prog ()
    (func foo (x) (plus x 2)))
(cond (nonequal (foo 1) 2)
    (return false))

; test the return value of `prog`
(cond (nonequal (prog () 1 2 3) 3)
    (return false))

; test that `return` inside `prog` returns from the function
(func foo ()
    (prog () (return 42))
    (divide 1 0))
(cond (nonequal (foo) 42)
    (return false))

(prog ()
    (return true)
    false)
